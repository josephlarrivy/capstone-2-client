{"ast":null,"code":"/*!\n * Connect - bodyParser\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar qs = require('qs');\n\n/**\n * Extract the mime type from the given request's\n * _Content-Type_ header.\n *\n * @param  {IncomingMessage} req\n * @return {String}\n * @api private\n */\n\nfunction mime(req) {\n  var str = req.headers['content-type'] || '';\n  return str.split(';')[0];\n}\n\n/**\n * Parse request bodies.\n *\n * By default _application/json_ and _application/x-www-form-urlencoded_\n * are supported, however you may map `connect.bodyParser.parse[contentType]`\n * to a function of your choice to replace existing parsers, or implement\n * one for other content-types.\n *\n * Examples:\n *\n *      connect.createServer(\n *          connect.bodyParser()\n *        , function(req, res) {\n *          res.end('viewing user ' + req.body.user.name);\n *        }\n *      );\n *\n * Since both _json_ and _x-www-form-urlencoded_ are supported by\n * default, either of the following requests would result in the response\n * of \"viewing user tj\".\n *\n *      $ curl -d 'user[name]=tj' http://localhost/\n *      $ curl -d '{\"user\":{\"name\":\"tj\"}}' -H \"Content-Type: application/json\" http://localhost/\n *\n * @return {Function}\n * @api public\n */\n\nexports = module.exports = function bodyParser() {\n  return function bodyParser(req, res, next) {\n    var parser = exports.parse[mime(req)];\n    if (parser && !req.body) {\n      var data = '';\n      req.setEncoding('utf8');\n      req.on('data', function (chunk) {\n        data += chunk;\n      });\n      req.on('end', function () {\n        req.rawBody = data;\n        try {\n          req.body = data ? parser(data) : {};\n        } catch (err) {\n          return next(err);\n        }\n        next();\n      });\n    } else {\n      next();\n    }\n  };\n};\n\n/**\n * Supported decoders.\n *\n *  - application/x-www-form-urlencoded\n *  - application/json\n */\n\nexports.parse = {\n  'application/x-www-form-urlencoded': qs.parse,\n  'application/json': JSON.parse\n};","map":{"version":3,"names":["qs","require","mime","req","str","headers","split","exports","module","bodyParser","res","next","parser","parse","body","data","setEncoding","on","chunk","rawBody","err","JSON"],"sources":["/Users/josephlarrivy/software-engineering/springboard/assignments/capstone-2-rework/front-end/node_modules/facebook-sdk/node_modules/connect/lib/middleware/bodyParser.js"],"sourcesContent":["\n/*!\n * Connect - bodyParser\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar qs = require('qs');\n\n/**\n * Extract the mime type from the given request's\n * _Content-Type_ header.\n *\n * @param  {IncomingMessage} req\n * @return {String}\n * @api private\n */\n\nfunction mime(req) {\n  var str = req.headers['content-type'] || '';\n  return str.split(';')[0];\n}\n\n/**\n * Parse request bodies.\n *\n * By default _application/json_ and _application/x-www-form-urlencoded_\n * are supported, however you may map `connect.bodyParser.parse[contentType]`\n * to a function of your choice to replace existing parsers, or implement\n * one for other content-types.\n *\n * Examples:\n *\n *      connect.createServer(\n *          connect.bodyParser()\n *        , function(req, res) {\n *          res.end('viewing user ' + req.body.user.name);\n *        }\n *      );\n *\n * Since both _json_ and _x-www-form-urlencoded_ are supported by\n * default, either of the following requests would result in the response\n * of \"viewing user tj\".\n *\n *      $ curl -d 'user[name]=tj' http://localhost/\n *      $ curl -d '{\"user\":{\"name\":\"tj\"}}' -H \"Content-Type: application/json\" http://localhost/\n *\n * @return {Function}\n * @api public\n */\n\nexports = module.exports = function bodyParser(){\n  return function bodyParser(req, res, next) {\n    var parser = exports.parse[mime(req)];\n    if (parser && !req.body) {\n      var data = '';\n      req.setEncoding('utf8');\n      req.on('data', function(chunk) { data += chunk; });\n      req.on('end', function(){\n        req.rawBody = data;\n        try {\n          req.body = data\n            ? parser(data)\n            : {};\n        } catch (err) {\n          return next(err);\n        }\n        next();\n      });\n    } else {\n      next();\n    }\n  }\n};\n\n/**\n * Supported decoders.\n *\n *  - application/x-www-form-urlencoded\n *  - application/json\n */\n\nexports.parse = {\n    'application/x-www-form-urlencoded': qs.parse\n  , 'application/json': JSON.parse\n};"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,IAAIA,CAACC,GAAG,EAAE;EACjB,IAAIC,GAAG,GAAGD,GAAG,CAACE,OAAO,CAAC,cAAc,CAAC,IAAI,EAAE;EAC3C,OAAOD,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAC,OAAO,GAAGC,MAAM,CAACD,OAAO,GAAG,SAASE,UAAUA,CAAA,EAAE;EAC9C,OAAO,SAASA,UAAUA,CAACN,GAAG,EAAEO,GAAG,EAAEC,IAAI,EAAE;IACzC,IAAIC,MAAM,GAAGL,OAAO,CAACM,KAAK,CAACX,IAAI,CAACC,GAAG,CAAC,CAAC;IACrC,IAAIS,MAAM,IAAI,CAACT,GAAG,CAACW,IAAI,EAAE;MACvB,IAAIC,IAAI,GAAG,EAAE;MACbZ,GAAG,CAACa,WAAW,CAAC,MAAM,CAAC;MACvBb,GAAG,CAACc,EAAE,CAAC,MAAM,EAAE,UAASC,KAAK,EAAE;QAAEH,IAAI,IAAIG,KAAK;MAAE,CAAC,CAAC;MAClDf,GAAG,CAACc,EAAE,CAAC,KAAK,EAAE,YAAU;QACtBd,GAAG,CAACgB,OAAO,GAAGJ,IAAI;QAClB,IAAI;UACFZ,GAAG,CAACW,IAAI,GAAGC,IAAI,GACXH,MAAM,CAACG,IAAI,CAAC,GACZ,CAAC,CAAC;QACR,CAAC,CAAC,OAAOK,GAAG,EAAE;UACZ,OAAOT,IAAI,CAACS,GAAG,CAAC;QAClB;QACAT,IAAI,EAAE;MACR,CAAC,CAAC;IACJ,CAAC,MAAM;MACLA,IAAI,EAAE;IACR;EACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEAJ,OAAO,CAACM,KAAK,GAAG;EACZ,mCAAmC,EAAEb,EAAE,CAACa,KAAK;EAC7C,kBAAkB,EAAEQ,IAAI,CAACR;AAC7B,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}