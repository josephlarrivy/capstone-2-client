{"ast":null,"code":"/*!\n * Connect - session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Session = require('./session/session'),\n  MemoryStore = require('./session/memory'),\n  Cookie = require('./session/cookie'),\n  Store = require('./session/store'),\n  utils = require('./../utils'),\n  parse = require('url').parse,\n  crypto = require('crypto');\n\n// environment\n\nvar env = process.env.NODE_ENV;\n\n/**\n * Expose the middleware.\n */\n\nexports = module.exports = session;\n\n/**\n * Expose constructors.\n */\n\nexports.Store = Store;\nexports.Cookie = Cookie;\nexports.Session = Session;\nexports.MemoryStore = MemoryStore;\n\n/**\n * Warning message for `MemoryStore` usage in production.\n */\n\nvar warning = 'Warning: connection.session() MemoryStore is not\\n' + 'designed for a production environment, as it will leak\\n' + 'memory, and obviously only work within a single process.';\n\n/**\n * Default finger-printing function.\n */\n\nfunction defaultFingerprint(req) {\n  return req.headers['user-agent'] || '';\n}\n;\n\n/**\n * Paths to ignore, defaulting to `/favicon.ico`.\n */\n\nexports.ignore = ['/favicon.ico'];\n\n/**\n * Setup session store with the given `options`.\n *\n * Session data is _not_ saved in the cookie itself, however\n * cookies are used, so we must use the [cookieParser()](middleware-cookieParser.html)\n * middleware _before_ `session()`.\n *\n * Examples:\n *\n *     connect.createServer(\n *         connect.cookieParser()\n *       , connect.session({ secret: 'keyboard cat' })\n *     );\n *\n * Options:\n *\n *   - `key`           cookie name defaulting to `connect.sid`\n *   - `store`         Session store instance\n *   - `fingerprint`   Custom fingerprint generating function\n *   - `cookie`        Session cookie settings, defaulting to `{ path: '/', httpOnly: true, maxAge: 14400000 }`\n *   - `secret`        Secret string used to compute hash\n *\n * Ignore Paths:\n *\n *  By default `/favicon.ico` is the only ignored path, all others\n *  will utilize sessions, to manipulate the paths ignored, use\n * `connect.session.ignore.push('/my/path')`. This works for _full_\n *  pathnames only, not segments nor substrings.\n *\n *     connect.session.ignore.push('/robots.txt');\n *\n * ## req.session\n *\n *  To store or access session data, simply use the request property `req.session`,\n *  which is (generally) serialized as JSON by the store, so nested objects \n *  are typically fine. For example below is a user-specific view counter:\n *\n *       connect(\n *           connect.cookieParser()\n *         , connect.session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }})\n *         , connect.favicon()\n *         , function(req, res, next){\n *           var sess = req.session;\n *           if (sess.views) {\n *             res.setHeader('Content-Type', 'text/html');\n *             res.write('<p>views: ' + sess.views + '</p>');\n *             res.write('<p>expires in: ' + (sess.cookie.maxAge / 1000) + 's</p>');\n *             res.end();\n *             sess.views++;\n *           } else {\n *             sess.views = 1;\n *             res.end('welcome to the session demo. refresh!');\n *           }\n *         }\n *       ).listen(3000);\n *\n * ## Session#regenerate()\n *\n *  To regenerate the session simply invoke the method, once complete\n *  a new SID and `Session` instance will be initialized at `req.session`.\n *\n *      req.session.regenerate(function(err){\n *        // will have a new session here\n *      });\n *\n * ## Session#destroy()\n *\n *  Destroys the session, removing `req.session`, will be re-generated next request.\n *\n *      req.session.destroy(function(err){\n *        // cannot access session here\n *      });\n * \n * ## Session#reload()\n *\n *  Reloads the session data.\n *\n *      req.session.reload(function(err){\n *        // session updated\n *      });\n *\n * ## Session#save()\n *\n *  Save the session.\n *\n *      req.session.save(function(err){\n *        // session saved\n *      });\n *\n * ## Session#touch()\n *\n *   Updates the `.maxAge`, and `.lastAccess` properties. Typically this is\n *   not necessary to call, as the session middleware does this for you.\n *\n * ## Session#cookie\n *\n *  Each session has a unique cookie object accompany it. This allows\n *  you to alter the session cookie per visitor. For example we can\n *  set `req.session.cookie.expires` to `false` to enable the cookie\n *  to remain for only the duration of the user-agent.\n *\n * ## Session#maxAge\n *\n *  Alternatively `req.session.cookie.maxAge` will return the time\n *  remaining in milliseconds, which we may also re-assign a new value\n *  to adjust the `.expires` property appropriately. The following\n *  are essentially equivalent\n *\n *     var hour = 3600000;\n *     req.session.cookie.expires = new Date(Date.now() + hour);\n *     req.session.cookie.maxAge = hour;\n *\n * For example when `maxAge` is set to `60000` (one minute), and 30 seconds\n * has elapsed it will return `30000` until the current request has completed,\n * at which time `req.session.touch()` is called to update `req.session.lastAccess`,\n * and reset `req.session.maxAge` to its original value.\n *\n *     req.session.cookie.maxAge;\n *     // => 30000\n *\n * Session Store Implementation:\n *\n * Every session store _must_ implement the following methods\n *\n *    - `.get(sid, callback)`\n *    - `.set(sid, session, callback)`\n *    - `.destroy(sid, callback)`\n *\n * Recommended methods include, but are not limited to:\n *\n *    - `.length(callback)`\n *    - `.clear(callback)`\n *\n * For an example implementation view the [connect-redis](http://github.com/visionmedia/connect-redis) repo.\n *\n * @param {Object} options\n * @return {Function}\n * @api public\n */\n\nfunction session(options) {\n  var options = options || {},\n    key = options.key || 'connect.sid',\n    secret = options.secret,\n    store = options.store || new MemoryStore(),\n    fingerprint = options.fingerprint || defaultFingerprint,\n    cookie = options.cookie;\n\n  // notify user that this store is not\n  // meant for a production environment\n  if ('production' == env && store instanceof MemoryStore) {\n    console.warn(warning);\n  }\n\n  // ensure secret is present\n  if (!secret) {\n    throw new Error('connect.session({ secret: \"string\" }) required for security');\n  }\n\n  // session hashing function\n  store.hash = function (req, base) {\n    return crypto.createHmac('sha256', secret).update(base + fingerprint(req)).digest('base64').replace(/=*$/, '');\n  };\n\n  // generates the new session\n  store.generate = function (req) {\n    var base = utils.uid(24);\n    var sessionID = base + '.' + store.hash(req, base);\n    req.sessionID = sessionID;\n    req.session = new Session(req);\n    req.session.cookie = new Cookie(cookie);\n  };\n  return function session(req, res, next) {\n    // self-awareness\n    if (req.session) return next();\n\n    // parse url\n    var url = parse(req.url),\n      path = url.pathname;\n\n    // ignorable paths\n    if (~exports.ignore.indexOf(path)) return next();\n\n    // expose store\n    req.sessionStore = store;\n\n    // proxy writeHead() to Set-Cookie\n    var writeHead = res.writeHead;\n    res.writeHead = function (status, headers) {\n      if (req.session) {\n        var cookie = req.session.cookie;\n        // only send secure session cookies when there is a secure connection.\n        // proxySecure is a custom attribute to allow for a reverse proxy\n        // to handle SSL connections and to communicate to connect over HTTP that\n        // the incoming connection is secure.\n        var secured = cookie.secure && (req.connection.encrypted || req.connection.proxySecure);\n        if (secured || !cookie.secure) {\n          res.setHeader('Set-Cookie', cookie.serialize(key, req.sessionID));\n        }\n      }\n      res.writeHead = writeHead;\n      return res.writeHead(status, headers);\n    };\n\n    // proxy end() to commit the session\n    var end = res.end;\n    res.end = function (data, encoding) {\n      res.end = end;\n      if (req.session) {\n        // HACK: ensure Set-Cookie for implicit writeHead()\n        if (!res._header) res._implicitHeader();\n        req.session.resetMaxAge();\n        req.session.save(function () {\n          res.end(data, encoding);\n        });\n      } else {\n        res.end(data, encoding);\n      }\n    };\n\n    // session hashing\n    function hash(base) {\n      return store.hash(req, base);\n    }\n\n    // generate the session\n    function generate() {\n      store.generate(req);\n    }\n\n    // get the sessionID from the cookie\n    req.sessionID = req.cookies[key];\n\n    // make a new session if the browser doesn't send a sessionID\n    if (!req.sessionID) {\n      generate();\n      next();\n      return;\n    }\n\n    // check the fingerprint\n    var parts = req.sessionID.split('.');\n    if (parts[1] != hash(parts[0])) {\n      generate();\n      next();\n      return;\n    }\n\n    // generate the session object\n    var pause = utils.pause(req);\n    store.get(req.sessionID, function (err, sess) {\n      // proxy to resume() events\n      var _next = next;\n      next = function (err) {\n        _next(err);\n        pause.resume();\n      };\n\n      // error handling\n      if (err) {\n        if ('ENOENT' == err.code) {\n          generate();\n          next();\n        } else {\n          next(err);\n        }\n        // no session\n      } else if (!sess) {\n        generate();\n        next();\n        // populate req.session\n      } else {\n        store.createSession(req, sess);\n        next();\n      }\n    });\n  };\n}\n;","map":{"version":3,"names":["Session","require","MemoryStore","Cookie","Store","utils","parse","crypto","env","process","NODE_ENV","exports","module","session","warning","defaultFingerprint","req","headers","ignore","options","key","secret","store","fingerprint","cookie","console","warn","Error","hash","base","createHmac","update","digest","replace","generate","uid","sessionID","res","next","url","path","pathname","indexOf","sessionStore","writeHead","status","secured","secure","connection","encrypted","proxySecure","setHeader","serialize","end","data","encoding","_header","_implicitHeader","resetMaxAge","save","cookies","parts","split","pause","get","err","sess","_next","resume","code","createSession"],"sources":["/Users/josephlarrivy/software-engineering/springboard/assignments/capstone-2-rework/front-end/node_modules/facebook-sdk/node_modules/connect/lib/middleware/session.js"],"sourcesContent":["\n/*!\n * Connect - session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Session = require('./session/session')\n  , MemoryStore = require('./session/memory')\n  , Cookie = require('./session/cookie')\n  , Store = require('./session/store')\n  , utils = require('./../utils')\n  , parse = require('url').parse\n  , crypto = require('crypto');\n\n// environment\n\nvar env = process.env.NODE_ENV;\n\n/**\n * Expose the middleware.\n */\n\nexports = module.exports = session;\n\n/**\n * Expose constructors.\n */\n\nexports.Store = Store;\nexports.Cookie = Cookie;\nexports.Session = Session;\nexports.MemoryStore = MemoryStore;\n\n/**\n * Warning message for `MemoryStore` usage in production.\n */\n\nvar warning = 'Warning: connection.session() MemoryStore is not\\n'\n  + 'designed for a production environment, as it will leak\\n'\n  + 'memory, and obviously only work within a single process.';\n\n/**\n * Default finger-printing function.\n */\n\nfunction defaultFingerprint(req) {\n  return req.headers['user-agent'] || '';\n};\n\n/**\n * Paths to ignore, defaulting to `/favicon.ico`.\n */\n\nexports.ignore = ['/favicon.ico'];\n\n/**\n * Setup session store with the given `options`.\n *\n * Session data is _not_ saved in the cookie itself, however\n * cookies are used, so we must use the [cookieParser()](middleware-cookieParser.html)\n * middleware _before_ `session()`.\n *\n * Examples:\n *\n *     connect.createServer(\n *         connect.cookieParser()\n *       , connect.session({ secret: 'keyboard cat' })\n *     );\n *\n * Options:\n *\n *   - `key`           cookie name defaulting to `connect.sid`\n *   - `store`         Session store instance\n *   - `fingerprint`   Custom fingerprint generating function\n *   - `cookie`        Session cookie settings, defaulting to `{ path: '/', httpOnly: true, maxAge: 14400000 }`\n *   - `secret`        Secret string used to compute hash\n *\n * Ignore Paths:\n *\n *  By default `/favicon.ico` is the only ignored path, all others\n *  will utilize sessions, to manipulate the paths ignored, use\n * `connect.session.ignore.push('/my/path')`. This works for _full_\n *  pathnames only, not segments nor substrings.\n *\n *     connect.session.ignore.push('/robots.txt');\n *\n * ## req.session\n *\n *  To store or access session data, simply use the request property `req.session`,\n *  which is (generally) serialized as JSON by the store, so nested objects \n *  are typically fine. For example below is a user-specific view counter:\n *\n *       connect(\n *           connect.cookieParser()\n *         , connect.session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }})\n *         , connect.favicon()\n *         , function(req, res, next){\n *           var sess = req.session;\n *           if (sess.views) {\n *             res.setHeader('Content-Type', 'text/html');\n *             res.write('<p>views: ' + sess.views + '</p>');\n *             res.write('<p>expires in: ' + (sess.cookie.maxAge / 1000) + 's</p>');\n *             res.end();\n *             sess.views++;\n *           } else {\n *             sess.views = 1;\n *             res.end('welcome to the session demo. refresh!');\n *           }\n *         }\n *       ).listen(3000);\n *\n * ## Session#regenerate()\n *\n *  To regenerate the session simply invoke the method, once complete\n *  a new SID and `Session` instance will be initialized at `req.session`.\n *\n *      req.session.regenerate(function(err){\n *        // will have a new session here\n *      });\n *\n * ## Session#destroy()\n *\n *  Destroys the session, removing `req.session`, will be re-generated next request.\n *\n *      req.session.destroy(function(err){\n *        // cannot access session here\n *      });\n * \n * ## Session#reload()\n *\n *  Reloads the session data.\n *\n *      req.session.reload(function(err){\n *        // session updated\n *      });\n *\n * ## Session#save()\n *\n *  Save the session.\n *\n *      req.session.save(function(err){\n *        // session saved\n *      });\n *\n * ## Session#touch()\n *\n *   Updates the `.maxAge`, and `.lastAccess` properties. Typically this is\n *   not necessary to call, as the session middleware does this for you.\n *\n * ## Session#cookie\n *\n *  Each session has a unique cookie object accompany it. This allows\n *  you to alter the session cookie per visitor. For example we can\n *  set `req.session.cookie.expires` to `false` to enable the cookie\n *  to remain for only the duration of the user-agent.\n *\n * ## Session#maxAge\n *\n *  Alternatively `req.session.cookie.maxAge` will return the time\n *  remaining in milliseconds, which we may also re-assign a new value\n *  to adjust the `.expires` property appropriately. The following\n *  are essentially equivalent\n *\n *     var hour = 3600000;\n *     req.session.cookie.expires = new Date(Date.now() + hour);\n *     req.session.cookie.maxAge = hour;\n *\n * For example when `maxAge` is set to `60000` (one minute), and 30 seconds\n * has elapsed it will return `30000` until the current request has completed,\n * at which time `req.session.touch()` is called to update `req.session.lastAccess`,\n * and reset `req.session.maxAge` to its original value.\n *\n *     req.session.cookie.maxAge;\n *     // => 30000\n *\n * Session Store Implementation:\n *\n * Every session store _must_ implement the following methods\n *\n *    - `.get(sid, callback)`\n *    - `.set(sid, session, callback)`\n *    - `.destroy(sid, callback)`\n *\n * Recommended methods include, but are not limited to:\n *\n *    - `.length(callback)`\n *    - `.clear(callback)`\n *\n * For an example implementation view the [connect-redis](http://github.com/visionmedia/connect-redis) repo.\n *\n * @param {Object} options\n * @return {Function}\n * @api public\n */\n\nfunction session(options){\n  var options = options || {}\n    , key = options.key || 'connect.sid'\n    , secret = options.secret\n    , store = options.store || new MemoryStore\n    , fingerprint = options.fingerprint || defaultFingerprint\n    , cookie = options.cookie;\n\n  // notify user that this store is not\n  // meant for a production environment\n  if ('production' == env && store instanceof MemoryStore) {\n    console.warn(warning);\n  }\n\n  // ensure secret is present\n  if (!secret) {\n    throw new Error('connect.session({ secret: \"string\" }) required for security');\n  }\n\n  // session hashing function\n  store.hash = function(req, base) {\n    return crypto\n      .createHmac('sha256', secret)\n      .update(base + fingerprint(req))\n      .digest('base64')\n      .replace(/=*$/, '');\n  };\n\n  // generates the new session\n  store.generate = function(req){\n    var base = utils.uid(24);\n    var sessionID = base + '.' + store.hash(req, base);\n    req.sessionID = sessionID;\n    req.session = new Session(req);\n    req.session.cookie = new Cookie(cookie);\n  };\n\n  return function session(req, res, next) {\n    // self-awareness\n    if (req.session) return next();\n\n    // parse url\n    var url = parse(req.url)\n      , path = url.pathname;\n\n    // ignorable paths\n    if (~exports.ignore.indexOf(path)) return next();\n\n    // expose store\n    req.sessionStore = store;\n\n    // proxy writeHead() to Set-Cookie\n    var writeHead = res.writeHead;\n    res.writeHead = function(status, headers){\n      if (req.session) {\n        var cookie = req.session.cookie;\n        // only send secure session cookies when there is a secure connection.\n        // proxySecure is a custom attribute to allow for a reverse proxy\n        // to handle SSL connections and to communicate to connect over HTTP that\n        // the incoming connection is secure.\n        var secured = cookie.secure && (req.connection.encrypted || req.connection.proxySecure);\n        if (secured || !cookie.secure) {\n          res.setHeader('Set-Cookie', cookie.serialize(key, req.sessionID));\n        }\n      }\n\n      res.writeHead = writeHead;\n      return res.writeHead(status, headers);\n    };\n\n    // proxy end() to commit the session\n    var end = res.end;\n    res.end = function(data, encoding){\n      res.end = end;\n      if (req.session) {\n        // HACK: ensure Set-Cookie for implicit writeHead()\n        if (!res._header) res._implicitHeader();\n        req.session.resetMaxAge();\n        req.session.save(function(){\n          res.end(data, encoding);\n        });\n      } else {\n        res.end(data, encoding);\n      }\n    };\n\n    // session hashing\n    function hash(base) {\n      return store.hash(req, base);\n    }\n\n    // generate the session\n    function generate() {\n      store.generate(req);\n    }\n\n    // get the sessionID from the cookie\n    req.sessionID = req.cookies[key];\n\n    // make a new session if the browser doesn't send a sessionID\n    if (!req.sessionID) {\n      generate();\n      next();\n      return;\n    }\n\n    // check the fingerprint\n    var parts = req.sessionID.split('.');\n    if (parts[1] != hash(parts[0])) {\n      generate();\n      next();\n      return;\n    }\n\n    // generate the session object\n    var pause = utils.pause(req);\n    store.get(req.sessionID, function(err, sess){\n      // proxy to resume() events\n      var _next = next;\n      next = function(err){\n        _next(err);\n        pause.resume();\n      }\n\n      // error handling\n      if (err) {\n        if ('ENOENT' == err.code) {\n          generate();\n          next();\n        } else {\n          next(err);\n        }\n      // no session\n      } else if (!sess) {\n        generate();\n        next();\n      // populate req.session\n      } else {\n        store.createSession(req, sess);\n        next();\n      }\n    });\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}